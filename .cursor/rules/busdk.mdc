---
description: "Main Design for busdk/busdk"
alwaysApply: true
globs: ["*"]
---

You are Cursor AI working inside a Git repository whose only purpose is to
implement the BusDK superproject repository at `busdk/busdk`. This repository
must not implement any accounting logic and must not contain any BusDK module
source code directly. Its job is to bundle the `bus` dispatcher and all `bus-*`
modules as Git submodules, pin compatible versions by submodule commit SHA, and
provide a single, reproducible, script-friendly entrypoint to build and install
the whole BusDK CLI toolchain.

Keep the superproject minimal and predictable. All BusDK submodules must live as
top-level directories at the repository root. Maintainership may add, remove, or
rename modules over time; the superproject must not require its specification to
be updated to list module names. The superproject treats the checked-in submodule
commit SHAs as the authoritative pins; do not add any separate lockfile.

The repository must include exactly one orchestration entrypoint: a root
`Makefile`. It must provide a stable interface for initializing submodules,
building all tools, and installing them into a chosen prefix, using only a
standard POSIX shell, `git`, and POSIX `make`. Avoid clever or obscure Make
features; prefer straightforward shell loops and simple variable plumbing so the
Makefile works on common Linux and macOS environments.

Module discovery must be automatic. The root Makefile must discover modules by
looking up directories at the superproject root, rather than hardcoding a list.
By default it must include the `bus` dispatcher directory if present, and every
top-level directory matching `bus-*` if present. Treat only existing directories
as modules, and only those that contain a `Makefile` as buildable modules. Sort
the discovered module list deterministically so `make build` and `make install`
run in a stable order across machines.

The root Makefile must not re-implement module build or install logic. Each
submodule repository is authoritative for how it builds and installs itself, and
the root Makefile must delegate to each module’s own `Makefile` using `make -C`.
The root Makefile may pass standardized variables (like output and prefix paths),
but it must not replicate per-module compilation commands, install-copy logic, or
other module-specific behavior in the superproject.

Define the public root Makefile contract precisely. The default target must print
a short help text showing available targets and the most important variables,
plus a typical usage example (`make bootstrap`, optionally overriding `PREFIX`).
Provide at least these targets with these semantics:

`init` initializes and fetches all submodules as pinned by the superproject,
using recursive submodule init/update so a fresh clone can be made ready in one
command.

`update` syncs and updates submodules to the pinned commits; it must not advance
submodules to newer upstream commits.

`upgrade` is an explicit opt-in maintainer target that updates submodules to the
latest commit on their configured remote tracking branches (intentionally moving
pins). It must not run as part of `init`, `update`, `build`, or `install`.

`status` prints `git submodule status --recursive` so the pinned state is visible.

`build` delegates to every discovered module (including `bus`) via `$(MAKE) -C`,
invoking the module’s `build` target. The build must fail fast if any module
fails, and error output must clearly identify which module failed.

`install` delegates to every discovered module via `$(MAKE) -C`, invoking the
module’s `install` target. The install must fail fast if any module fails.

`clean` removes superproject-local build artifacts (e.g. the root build output
directory), and may also delegate `clean` to each module via `make -C`, but must
not delete or deinitialize submodules.

`distclean` removes superproject-local build artifacts and also deinitializes
submodules to return the working tree to a “fresh clone” state.

`bootstrap` (preferred over `all`) runs `init`, `build`, and `install` in that
order. It must be safe for a fresh clone and must not perform `upgrade`.

Define build and install path conventions, but keep implementation inside the
module Makefiles. The superproject build output directory must default to
`./bin` at the superproject root. The install location must default to a
user-writable prefix using `PREFIX ?= $(HOME)/.local` and `BINDIR ?= $(PREFIX)/bin`.
The root Makefile must pass these variables through when delegating to modules so
all modules install into the same prefix and can share the same local build
output directory. The root Makefile must ensure `make install` results in
`$(BINDIR)` existing (either by creating it itself or by requiring modules to do
so; prefer requiring modules to do it to keep logic centralized).

Define the cross-module Makefile interface contract that the root Makefile relies
on. Each module repository’s Makefile must support at least: `build`, `install`,
and `clean`. Each module must accept `BIN_DIR` (or equivalent) so it can place
its compiled executable into the superproject’s `./bin` directory when invoked
from the root. Each module must accept `PREFIX` and `BINDIR` so installs are
consistent. The root Makefile must invoke modules strictly via `make -C <dir>`
and pass through `GO ?= go`, `GOFLAGS`, and `CGO_ENABLED` from the environment
without interpreting them.

Assume the normal convention that a module’s produced executable name matches
its directory name: `bus` produces `bus`, and any directory `bus-<name>` produces
an executable named `bus-<name>`. The superproject must not hardcode the set of
expected executables; it must rely on module discovery and on each module
Makefile producing the expected binary for its own directory name.

Write documentation in `README.md` only, and keep it strictly about this
superproject. Document what this repository is for, and explicitly state that
module development happens in the individual `bus-*` repositories while this
repo only pins versions and orchestrates build/install. Document that modules are
Git submodules at the repository root and that new `bus-*` directories are
picked up automatically by the root Makefile. Document the common workflows:
clone and run `make bootstrap`; syncing to pinned commits with `make update`; and
how maintainers intentionally move pins with `make upgrade` followed by
committing the resulting submodule SHA changes. Document the build output
directory and the install prefix variables. Keep the README concise, practical,
and focused.

Do not add any Go source code, no CLI binaries, no network features, no package
manager integration, and no additional build systems beyond this one root
Makefile and the delegated module Makefiles. Keep the repository minimal, clear,
and aligned with the goal of being the single reproducible entrypoint for
building and installing the complete BusDK CLI toolchain.