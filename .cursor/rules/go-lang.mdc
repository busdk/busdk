---
description: "Prescribe idiomatic Go practices for structure, documentation, errors, concurrency, refactoring, and testing, with code organized into small cohesive files and thoroughly covered by unit tests."
globs: [ "**/*.go", "go.mod", "go.sum" ]
alwaysApply: false
---

This rule ensures all Go code is clear, idiomatic, and easy to maintain. Code
is split into semantically meaningful, small files and packages with single,
focused responsibilities. Projects are built as Go modules so builds are
reproducible and the public API remains stable as the code evolves. The goal is
to keep units independent and composable while reflecting the natural structure
of the domain in packages and files.

Package organization favors clear import paths and names that read well at call
sites while avoiding stutter, and the exported surface is kept minimal.
Internal details remain unexported to reduce coupling and prevent dependency
cycles, and larger packages are refactored into smaller ones when
responsibilities drift.

All code must be well documented inside the source using proper doc comments.
Every package begins with a concise package comment, and each exported
identifier has a complete sentence comment that explains what it does and how
to use it. Executable examples are added where helpful so that documentation
and behavior stay in sync through automated verification.

Error handling uses explicit error values that callers check immediately.
Errors are wrapped or annotated to preserve context without obscuring the root
cause, and panics are reserved for programmer errors and truly unrecoverable
states rather than for expected control flow. Resources such as files, sockets,
and locks are released deterministically, with cleanup deferred immediately
after successful acquisition so that all return paths are safe and leak free.

Concurrency design is explicit about ownership and lifetimes. Long running or
cancelable operations accept a context parameter, observe its deadlines and
cancellation, and propagate it across goroutines. Goroutines are started only
when their stop conditions are defined, and the race detector is used routinely
to reveal data hazards during development and test runs.

Whenever a function grows long, the assistant evaluates its contents for
reusable logic and extracts coherent parts into their own well named helper
functions. The aim is to keep individual functions short and focused so that
control flow is easy to read, side effects are contained, and the logic is
straightforward to unit test in isolation. Extracted helpers should have clear
inputs and outputs, avoid hidden global state, and be written to enable
deterministic tests that cover both success and failure paths without elaborate
scaffolding.

Testing is mandatory for all production code and must cover success paths,
failures, and edge cases. Unit tests prefer table driven structure and subtests
where it clarifies intent, benchmarks measure performance critical paths,
examples illustrate usage while doubling as executable documentation, and fuzz
tests explore unexpected inputs. A change is not complete until the relevant
tests exist and pass locally and in continuous integration with the race
detector enabled where appropriate.

Tooling is part of everyday workflow. Source is formatted automatically, static
analysis and vet are run to catch issues the compiler cannot, and an
opinionated linter runner may be used to enforce additional checks consistently
across the project. Compatibility and reproducibility are maintained through
modules and standard tooling so that dependency versions are recorded precisely
and updates are introduced without breaking stable behavior.

The codebase remains small and modular by continuously reshaping large files or
packages into tighter units with clear responsibilities and stable boundaries.
The smallest workable abstraction is preferred over premature layering so that
each unit can be understood, tested, and evolved independently while keeping
the whole system predictable and maintainable.

In this repository, follow standard Go project layout conventions. Put the 
end-user executable entrypoint under cmd/<binary-name>/main.go, where 
<binary-name> is the produced binary name. Put reusable, repository-internal 
code under internal/ with clear subpackages such as internal/cli for argument 
and flag parsing, internal/accounts for accounts domain logic, internal/storage 
for file I/O helpers, and internal/validate for schema and data validation 
utilities. Keep exported identifiers minimal and prefer small packages with 
single responsibilities. Put public Go packages intended to be imported by 
other repositories only under pkg/; if nothing is meant to be imported 
externally, do not create pkg/. Put tests alongside the code they test using 
*_test.go files in the same package. Put any test fixtures you must commit 
under testdata/ and ensure tests can also generate fixtures in temporary 
directories when appropriate. Keep the module definition at the repository root 
in go.mod and go.sum. Put documentation at the repository root as README.md. 
Put build and developer automation at the repository root as Makefile. Use 
consistent naming, avoid deep nesting unless necessary, and keep cmd/ thin by 
moving real logic into internal packages so it is unit-testable.
